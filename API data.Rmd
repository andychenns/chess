---
title: "Chess API"
author: "LonghaoChen"
date: "3/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(httr)
library(jsonlite)
library(tidyverse)

library(curl)
library(dplyr)
library(bigchess)
```

```{r}
res = GET("https://lichess.org/player",add_headers(c('Authorization'=paste0('Bearer ','Z9XOFSxKsWuf3vt1'),'Accept'='application/vnd.lichess.v3+json')))


httr::http_type(res)

data <- fromJSON(rawToChar(res$content)) 
data
```

```{r}
res = GET("https://lichess.org/streamer/live",add_headers(c('Authorization'=paste0('Bearer ','Z9XOFSxKsWuf3vt1'),'Accept'='application/vnd.lichess.v3+json')))


httr::http_type(res)

data <- fromJSON(rawToChar(res$content)) 
data
```

```{r}
read.pgn <- function(con,add.tags = NULL,n.moves = T, extract.moves = 10,last.move = T,stat.moves = T,big.mode = F,quiet = F,ignore.other.games = F,source.movetext = F){
  st <- Sys.time()
  tags <- c(c("Event","Site","Date","Round","White","Black","Result"),add.tags)
  if(big.mode) al = con
  else{
    al = readLines(con)
    if("connection" %in% class(con)) close(con)
    }
  s <- "^\\[([\\S]+)\\s\"([\\S\\s]+|\\B)\"\\]$"
  tmp1 <- gsub(s,"\\1",al,perl = T)
  tmp2 <- gsub(s,"\\2",al, perl = T)
  tmp3 <- grepl("^\\[[^%]+\\]$",al,perl = T)
  tmp4 <- cumsum(grepl("\\[Event ",al))
  tmp1[!tmp3] <- "Movetext"
  r2 <- data.frame(tmp1,tmp2,tmp3,tmp4,stringsAsFactors = F)
  gt <- paste(subset(r2,tmp1=="Movetext",select = c(tmp2))[,1],collapse = " ")
  if(source.movetext) gt2 <- gt
  gt <- gsub("{[^}]+}","",gt,perl = T) #remove comments
  gt <- gsub("\\((?>[^()]|(?R))*\\)","",gt,perl = T) #remove variants (Recursive Annotation Variation)
  gt <- gsub("[\\?\\!]","",gt,perl = T) # remove ?! chars
  gt <- gsub("[0-9]+\\.\\.\\.","",gt,perl = T)
  gt <- gsub("\\$[0-9]+","",gt,perl = T) # remove NAG and SAN suffix
  for(i in c("1-0","1\\/2-1\\/2","0-1","\\*"))
    gt <- unlist(strsplit(gt,split = i))
  if(source.movetext) for(i in c("1-0","1\\/2-1\\/2","0-1","\\*")) gt2 <- unlist(strsplit(gt2,split = i))
  r <- subset(r2,tmp1 == "Event",select = c(tmp4,tmp2))
  colnames(r) <- c("GID","Event")
  #tags <- c("Event","Site","Date","Round","White","Black","Result")
  for(i in c(setdiff(tags,"Event"))){
    tmp <- subset(r2,tmp1 == i,select = c(tmp4,tmp2))
    colnames(tmp) <- c("GID",i)
    r <- merge(r,tmp,all.x = T)
  }
  r$Movetext <- trimws(gsub("[[:space:]]+"," ",head(gt,nrow(r))))
  if(source.movetext) r$SourceMovetext  <- head(gt2,nrow(r))
  tal <- tail(al,1) # check if scanning ended properly
  # otherwise mark last movetext as empty
  if(big.mode) if(!grepl("\\[",tal)&!(tal=="")) {
    r[nrow(r),"Movetext"] <- ""

  }
  # and remove this record from data frame
  if(big.mode) if(r[nrow(r),"Movetext"]=="")   r <- r[-nrow(r),]
  if(!quiet) message(paste0(Sys.time(),", successfully imported ",nrow(r)," games"))
  if(n.moves||extract.moves) 
    r$NMoves <- n_moves(r$Movetext)
  if(!quiet) message(paste0(Sys.time(),", N moves computed"))
  if(extract.moves){
    if(extract.moves==-1) {N <- max(r$NMoves)}
    else {N <- extract.moves}
    r <- cbind(r,extract_moves(r$Movetext,N,last.move = last.move))
    if(!quiet) message(paste0(Sys.time(),", extract moves done")) }
  if(stat.moves) {
    r <- cbind(r,stat_moves(r$Movetext))
    if(!quiet) message(paste0(Sys.time(),", stat moves computed"))
    }
  if(ignore.other.games)
  {
    nr <- nrow(r)
    r <- subset(r,Result!="*")
    r$Result <- factor(r$Result,levels = c("1-0","1/2-1/2","0-1"),labels=c("1-0","1/2-1/2","0-1"),ordered = T)
    if(!quiet) message(paste0(Sys.time(),", subset done (",nr-nrow(r)," games with Result '*' removed) "))

  }
  else{
    r$Result <- factor(r$Result,levels = c("1-0","1/2-1/2","0-1","*"),labels=c("1-0","1/2-1/2","0-1","*"),ordered = T)
  }
  r <- droplevels(r)
  for(i in intersect(colnames(r),c("WhiteElo","BlackElo","SetUp")))
    r[,i] <- as.integer(r[,i])

  return(r[,-1])
}
```


```{r}
require(ff)
require(ffbase)
f <- system.file("extdata", "/Users/longhaochen/Desktop/chess/data/standard_rated_2014-01.pgn.zip", package = "bigchess")
con <- gzfile(f,"rbt",encoding = "latin1")
# options("fftempdir"="/path/"...) # if necessarily
fdf <- read.pgn.ff(con,stat.moves = FALSE)
delete(fdf)
# Works with all types of connections (also gz or zip files).
# con argument is passed directly to readLines(con,batch.size)
# so (if total number of lines to read is greater then batch.size)
# depending on platform use it correctly:

# Linux/Mac OS X ('r' opening mode for loop over readLines):
con <- gzfile(system.file("extdata", "Carlsen.gz", package = "bigchess"),"r",encoding = "latin1")
# con <- file("path_to_big_chess_file.pgn","r",encoding = "latin1")
fdf <- read.pgn.ff(con)
delete(fdf)
```

