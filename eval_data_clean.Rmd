---
title: "eval_data_clean"
author: "LonghaoChen"
date: "10/19/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(readr)
library(strex)
```

```{r}
df <- read_csv("data/lichess-04-2017.csv", 
    col_types = cols(...1 = col_skip()))

```
We would want get these information from PGN, the eval, time left for the last move; or the second to the last move if black did not finish
```{r}

#Filter matches that does not have clock time

df <- filter(df, grepl(pattern = "clk", x=PGN, ignore.case = TRUE))


#First thing is to find out # of steps. The strategy is to count number of curly brackets and convert to steps

df$steps <- str_count(df$PGN, fixed("{"))

#The target move is to round down the steps column
df$target <- floor(df$steps/2)

#Extract subtext
df$last_move <- str_after_first(df$PGN, fixed(paste0(df$target, ". ")))
```



We will take the 1th to 8th digit after clk pattern match as the time left during last move
```{r}
#Remove any matches that does not have clock time
df$white_time_left <- substr(str_after_nth(df$last_move, fixed('clk'),1),1,8)
```

```{r}
#Find the clock time for black
df$black_time_left <- substr(str_after_nth(df$last_move, fixed('clk'),2),1,8)
```

Now we need to convert time from character to datetime and find the difference between white time left and black time left

```{r}
#If the difference is negative, black has more time left by the end. Otherwise, white has more time left by the end of the game.
df$time_left_difference <- as.numeric(as.difftime(df$white_time_left, units = "secs")) - as.numeric(as.difftime(df$black_time_left, units = "secs"))
```

We would like to calculate the average time left for difference result
```{r}
average_time_left <- df %>% group_by(Result) %>%
      summarise(average_time = mean(time_left_difference,na.rm=TRUE))

#We are also interested in how different game mode play into the effect of time
average_time_left_2 <- df %>% group_by(Result,Mode) %>%
      summarise(average_time = mean(time_left_difference,na.rm=TRUE), number_match = n())
```




Data visualization between match result and time left
```{r}
ggplot(df, aes(Result,scale(time_left_difference))) +
  geom_boxplot()

```

Conclusion, if you win the chess game, you are more likely to have more time left.

If we want to know the relationship between the time left difference and the result of game. We could fit a logistic regression and build a model.

```{r}
#Create a saperate df2 from df
df2 <- df[df$Result == "White Wins" | df$Result =="Black Wins",c("Result","time_left_difference")]
df2$Result <- factor(df2$Result)
mylogit <- glm(Result ~ time_left_difference, data = df2, family = "binomial")
summary(mylogit)
```


Next, we would like to know how much time people spend on each step across different game mode.

The data comes in with how much time left when each step is completed. To calculate the time spent on each step, we should take the time difference between each move. Then we can group by different game mode, and then summarize the statistics.

Summery or conclusion. We will break the entire match into 3 phases, the opening, middle game and endgame. Usually, the opening phases is the first 10-15 moves of the game. We will take 10th move as a cut between opening and middle. Then we will make a 60% versus 40% cut for the remaining moves. For example, a typical 50 moves match. The opening game is from move 1 to move 10. The middle game is from move 11 to 34 (11 + 0.6 * (50-10)) and the end game is from move 35 to 50.

For each phase, we could recommend the amount of time a player should spend for each move. We could also give an upper limit of time for a single move. Such as, a player should spend at most 15 seconds for a single move in a 5 minutes Classical game. If the time is spent more than 15 seconds, it will increases the likelihood of time forfeit significantly.
```{r}
df_statistics <- df_sample %>% group_by(Mode,Stage,Begin_Time) %>%
      summarise(average_time = mean(time_spent_each_step,na.rm=TRUE))
```




